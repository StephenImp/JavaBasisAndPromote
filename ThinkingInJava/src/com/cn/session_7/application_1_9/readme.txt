从概念上讲，构建器的职责是让对象实际进入存在状态。
在任何构建器内部，整个对象可能只是得到部分组织——我们只知道基础类对象已得到初始化，但却不知道哪些类已经继承。
然而，一个动态绑定的方法调用却会在分级结构里“向前”或者“向外”前进。
它调用位于衍生类里的一个方法。
如果在构建器内部做这件事情，那么对于调用的方法，它要操纵的成员可能尚未得到正确的初始化——这显然不是我们所希望的。


当Glyph 的构建器调用draw()时，radius 的值甚至不是默认的初始值1，而是0。这可能是由于一个点号或者屏幕上根本什么都没有画而造成的。
这样就不得不开始查找程序中的错误，试着找出程序不能工作的原因。
前一节讲述的初始化顺序并不十分完整，而那是解决问题的关键所在。
初始化的实际过程是这样的：
(1) 在采取其他任何操作之前，为对象分配的存储空间初始化成二进制零。
(2) 就象前面叙述的那样，调用基础类构建器。此时，被覆盖的draw()方法会得到调用（的确是在RoundGlyph 构建器调用之前），此时会发现radius 的值为0，这是由于步骤(1)造成的。
(3) 按照原先声明的顺序调用成员初始化代码。
(4) 调用衍生类构建器的主体。

    采取这些操作要求有一个前提，那就是所有东西都至少要初始化成零（或者某些特殊数据类型与“零”等价的值），
    而不是仅仅留作垃圾。其中包括通过“合成”技术嵌入一个类内部的对象句柄。
    如果假若忘记初始化那个句柄，就会在运行期间出现违例事件。
    其他所有东西都会变成零，这在观看结果时通常是一个严重的警告信号。
