抽象类和方法(application_1_...)

        通过这种方法，编译器可保证抽象类的“纯洁性”，我们不必担心会误用它。
        我的体会就是，保证抽象类中的抽象方法全部被重写而不会被误写成重载（application_1_5）


        如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为基础类中的所有抽象方法提供方法定义。
        如果不这样做（完全可以选择不做），则衍生类也会是抽象的，而且编译器会强迫我们用abstract 关键字标志那个类的“抽象”本质

        即使不包括任何abstract 方法，亦可将一个类声明成“抽象类”。
        如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。

        抽象-->属于       合成-->包含


接口(application_2_...)

        “interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。
        接口也包含了基本数据类型的数据成员，但它们都默认为static 和final

         使用接口最重要的一个原因：能上溯造型至多个基础类

         使用接口的第二个原因与使用抽象基础类的原因是一样的：
         防止客户程序员制作这个类的一个对象，以及规定它仅仅是一个接口。


        这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？
        若使用接口，我们可以同时获得抽象类以及接口的好处。
        所以假如想创建的基础类没有任何方法定义或者成员变量,那么无论如何都愿意使用接口，而不要选择抽象类。
        事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。

        只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。

内部类（application_3_...）

        将一个类定义置入另一个类定义中。这就叫作“内部类”。
        内部类对我们非常有用，因为利用它可对那些逻辑上相互联系的类进行分组，并可控制一个类在另一个类里的“可见性”。
        然而，我们必须认识到内部类与以前讲述的“合成”方法存在着根本的区别。
        通常，对内部类的需要并不是特别明显的，至少不会立即感觉到自己需要使用内部类。
        在本章的末尾，介绍内部类的所有语法之后，大家会发现一个特别的例子。通过它应该可以清晰地认识到内部类的好处。


        假若我们在一个方法甚至一个任意的作用域内创建内部类。有两方面的原因促使我们这样做：
        (1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。（application_3_2）
        (2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。